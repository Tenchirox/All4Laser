<<<<<<< SEARCH
pub fn show(ui: &mut Ui, layers: &mut [CutLayer], active_idx: usize) -> CutListAction {
    let mut action = CutListAction { select_layer: None, open_settings: None };

    ui.group(|ui| {
=======
use std::collections::HashSet;

pub fn show(ui: &mut Ui, layers: &mut [CutLayer], active_idx: usize, used_layers: &HashSet<usize>, hide_unused: &mut bool) -> CutListAction {
    let mut action = CutListAction { select_layer: None, open_settings: None };

    ui.horizontal(|ui| {
        ui.checkbox(hide_unused, "Hide Unused");
    });

    ui.group(|ui| {
>>>>>>> REPLACE
<<<<<<< SEARCH
                for (i, layer) in layers.iter_mut().enumerate() {
                    let is_active = i == active_idx;

                    // Row background for active
=======
                for (i, layer) in layers.iter_mut().enumerate() {
                    let is_active = i == active_idx;

                    if *hide_unused && !is_active && !used_layers.contains(&i) {
                        continue;
                    }

                    // Row background for active
>>>>>>> REPLACE
<<<<<<< SEARCH
                    // 5. Show (Visibility on preview? Actually `visible` usually means "Output to Laser").
                    // In LightBurn "Output" means send to laser, "Show" means show in preview.
                    // My struct `CutLayer` only has `visible`.
                    // Let's assume `visible` = Output.
                    // I don't have a separate "Hide from Preview" flag.
                    // Let's just use `visible` for "Output" column and skip "Show" column or duplicate it?
                    // Let's rename column 4 to "Enabled".
                    ui.label(if layer.visible { "ðŸ‘" } else { "Ã˜" });

                    ui.end_row();
=======
                    // 5. Show (Visibility in preview).
                    ui.checkbox(&mut layer.show, "");

                    ui.end_row();
>>>>>>> REPLACE
