/// Tiling: repeat a GCode job in an N×M grid

use egui::RichText;
use crate::theme;

pub struct TilingState {
    pub is_open: bool,
    pub cols: u32,
    pub rows: u32,
    pub spacing_x: f32,
    pub spacing_y: f32,
}

impl Default for TilingState {
    fn default() -> Self {
        Self {
            is_open: false,
            cols: 2,
            rows: 2,
            spacing_x: 110.0,
            spacing_y: 110.0,
        }
    }
}

pub struct TilingAction {
    pub apply: Option<Vec<String>>,
}

pub fn show(ctx: &egui::Context, state: &mut TilingState, source_lines: &[String]) -> TilingAction {
    let mut action = TilingAction { apply: None };

    if !state.is_open {
        return action;
    }

    let mut apply_clicked = false;
    let mut close_clicked = false;

    egui::Window::new("⊟ Tiling — Repeat Job")
        .resizable(false)
        .collapsible(false)
        .show(ctx, |ui| {
            egui::Grid::new("tiling_grid").num_columns(2).spacing([12.0, 6.0]).show(ui, |ui| {
                ui.label("Columns:");
                ui.add(egui::DragValue::new(&mut state.cols).range(1..=20));
                ui.end_row();
                ui.label("Rows:");
                ui.add(egui::DragValue::new(&mut state.rows).range(1..=20));
                ui.end_row();
                ui.label("Spacing X (mm):");
                ui.add(egui::DragValue::new(&mut state.spacing_x).speed(1.0).suffix(" mm"));
                ui.end_row();
                ui.label("Spacing Y (mm):");
                ui.add(egui::DragValue::new(&mut state.spacing_y).speed(1.0).suffix(" mm"));
                ui.end_row();
            });

            ui.label(
                RichText::new(format!("→ {} copies total", state.cols * state.rows))
                    .small()
                    .color(theme::SUBTEXT),
            );

            ui.add_space(8.0);
            ui.horizontal(|ui| {
                if ui.button(RichText::new("⊟ Apply Tiling").color(theme::GREEN).strong()).clicked() {
                    apply_clicked = true;
                }
                if ui.button("Close").clicked() {
                    close_clicked = true;
                }
            });
        });

    if apply_clicked && !source_lines.is_empty() {
        action.apply = Some(generate_tiled(state, source_lines));
    }
    if close_clicked {
        state.is_open = false;
    }

    action
}

fn generate_tiled(s: &TilingState, source: &[String]) -> Vec<String> {
    let mut out = Vec::new();
    out.push("; Tiled GCode — generated by All4Laser".into());
    out.push("G90 G21".into());

    for row in 0..s.rows {
        for col in 0..s.cols {
            let ox = col as f32 * s.spacing_x;
            let oy = row as f32 * s.spacing_y;
            out.push(format!("; Tile row={} col={} offset=({:.1},{:.1})", row, col, ox, oy));
            
            // Apply offset via G92 (coordinate system shift) then replay, then restore
            out.push(format!("G92 X{:.3} Y{:.3}", -ox, -oy));
            for line in source {
                let t = line.trim();
                // Skip header comments and global setup from source
                if t.starts_with(';') || t == "G90" || t == "G21" || t == "G90 G21" || t.is_empty() {
                    continue;
                }
                out.push(line.clone());
            }
            out.push("G92 X0 Y0".into()); // Restore offset
        }
    }

    out.push("M5".into());
    out.push("G0 X0 Y0 F3000".into());
    out
}
