/// Power/Speed Test Matrix Generator
/// Produces a grid of small squares, each engraved at a different power/speed combination

use crate::theme;

pub struct PowerSpeedTestState {
    pub is_open: bool,
    pub rows: u32,       // speed steps (Y axis)
    pub cols: u32,       // power steps (X axis)
    pub speed_min: f32,
    pub speed_max: f32,
    pub power_min: f32,
    pub power_max: f32,
    pub cell_size: f32,  // mm per cell
    pub cell_gap: f32,   // gap between cells in mm
    pub origin_x: f32,
    pub origin_y: f32,
}

impl Default for PowerSpeedTestState {
    fn default() -> Self {
        Self {
            is_open: false,
            rows: 5,
            cols: 5,
            speed_min: 200.0,
            speed_max: 2000.0,
            power_min: 100.0,
            power_max: 1000.0,
            cell_size: 10.0,
            cell_gap: 2.0,
            origin_x: 5.0,
            origin_y: 5.0,
        }
    }
}

pub struct PowerSpeedTestAction {
    pub generate: Option<Vec<String>>,
}

pub fn show(ctx: &egui::Context, state: &mut PowerSpeedTestState) -> PowerSpeedTestAction {
    let mut action = PowerSpeedTestAction { generate: None };

    if !state.is_open {
        return action;
    }

    let mut generate_clicked = false;
    let mut close = false;

    egui::Window::new("⊞ Power/Speed Test Matrix")
        .resizable(false)
        .collapsible(false)
        .show(ctx, |ui| {
            egui::Grid::new("pst_grid").num_columns(2).spacing([12.0, 6.0]).show(ui, |ui| {
                ui.label("Rows (speed steps):"); ui.add(egui::DragValue::new(&mut state.rows).range(1..=20)); ui.end_row();
                ui.label("Cols (power steps):"); ui.add(egui::DragValue::new(&mut state.cols).range(1..=20)); ui.end_row();
                ui.label("Speed min (mm/min):"); ui.add(egui::DragValue::new(&mut state.speed_min).speed(50.0)); ui.end_row();
                ui.label("Speed max (mm/min):"); ui.add(egui::DragValue::new(&mut state.speed_max).speed(50.0)); ui.end_row();
                ui.label("Power min (S):"); ui.add(egui::DragValue::new(&mut state.power_min).speed(10.0)); ui.end_row();
                ui.label("Power max (S):"); ui.add(egui::DragValue::new(&mut state.power_max).speed(10.0)); ui.end_row();
                ui.label("Cell size (mm):"); ui.add(egui::DragValue::new(&mut state.cell_size).range(2.0..=50.0)); ui.end_row();
                ui.label("Gap (mm):"); ui.add(egui::DragValue::new(&mut state.cell_gap).range(0.5..=10.0)); ui.end_row();
                ui.label("Origin X:"); ui.add(egui::DragValue::new(&mut state.origin_x)); ui.end_row();
                ui.label("Origin Y:"); ui.add(egui::DragValue::new(&mut state.origin_y)); ui.end_row();
            });

            let total_w = (state.cell_size + state.cell_gap) * state.cols as f32;
            let total_h = (state.cell_size + state.cell_gap) * state.rows as f32;
            ui.label(egui::RichText::new(format!("Total size: {:.0}×{:.0}mm | {} squares", total_w, total_h, state.rows * state.cols)).small());

            ui.add_space(8.0);
            ui.horizontal(|ui| {
                if ui.button(egui::RichText::new("⚡ Generate & Load").color(theme::GREEN).strong()).clicked() {
                    generate_clicked = true;
                }
                if ui.button("Close").clicked() {
                    close = true;
                }
            });
        });

    if generate_clicked {
        action.generate = Some(generate_gcode(state));
    }
    if close {
        state.is_open = false;
    }

    action
}

fn generate_gcode(s: &PowerSpeedTestState) -> Vec<String> {
    let mut lines = Vec::new();
    lines.push("; Power/Speed Test Matrix — generated by All4Laser".into());
    lines.push("G90 G21".into());
    lines.push("M5".into());

    let speed_step = if s.rows > 1 { (s.speed_max - s.speed_min) / (s.rows - 1) as f32 } else { 0.0 };
    let power_step = if s.cols > 1 { (s.power_max - s.power_min) / (s.cols - 1) as f32 } else { 0.0 };
    let step = s.cell_size + s.cell_gap;

    for row in 0..s.rows {
        let speed = s.speed_min + row as f32 * speed_step;
        for col in 0..s.cols {
            let power = s.power_min + col as f32 * power_step;

            let x0 = s.origin_x + col as f32 * step;
            let y0 = s.origin_y + row as f32 * step;
            let x1 = x0 + s.cell_size;
            let y1 = y0 + s.cell_size;

            lines.push(format!("; Row={} Col={} Speed={:.0} Power={:.0}", row, col, speed, power));
            lines.push(format!("M5"));
            lines.push(format!("G0 X{:.2} Y{:.2} F3000", x0, y0));
            lines.push(format!("M3 S{:.0}", power));
            // Fill with horizontal scan lines
            let scan_step = 0.1_f32;
            let mut y = y0;
            let mut left_to_right = true;
            while y <= y1 + 0.001 {
                let (start_x, end_x) = if left_to_right { (x0, x1) } else { (x1, x0) };
                lines.push(format!("G1 X{:.2} Y{:.2} F{:.0}", start_x, y, speed));
                lines.push(format!("G1 X{:.2} Y{:.2} F{:.0}", end_x, y, speed));
                y += scan_step;
                left_to_right = !left_to_right;
            }
            lines.push(format!("M5"));
        }
    }

    lines.push("M5".into());
    lines.push("G0 X0 Y0 F3000".into());
    lines
}
