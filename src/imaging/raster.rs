use image::{GrayImage, Luma};

/// Parameters for a cutting frame (outline) around the image
#[derive(Clone, Debug, PartialEq)]
pub struct OutlineParams {
    pub enabled: bool,
    pub speed: f32,
    pub power: f32,
    pub passes: u32,
}

impl Default for OutlineParams {
    fn default() -> Self {
        Self {
            enabled: false,
            speed: 500.0,
            power: 1000.0,
            passes: 1,
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum DitherMode {
    None,
    FloydSteinberg,
    Atkinson,
}

/// Parameters for raster-to-GCode conversion
#[derive(Clone, Debug, PartialEq)]
pub struct RasterParams {
    pub width_mm: f32,
    pub height_mm: f32,
    pub dpi: f32,
    pub max_speed: f32,
    pub max_power: f32,
    pub brightness: f32, // -1.0 to 1.0
    pub contrast: f32,   // 0.0 to 5.0 (1.0 is neutral)
    pub threshold: u8,   // 0-255 for vectorization
    pub flip_h: bool,
    pub flip_v: bool,
    pub rotation: i32,   // 0, 90, 180, 270
    pub _line_spacing: f32,
    pub dither: DitherMode,
    pub use_skeleton: bool, // New flag for skeletonization
    pub outline: OutlineParams,
}

impl Default for RasterParams {
    fn default() -> Self {
        Self {
            width_mm: 50.0,
            height_mm: 50.0,
            dpi: 254.0,       // 10 lines/mm
            max_speed: 1000.0,
            max_power: 1000.0,
            brightness: 0.0,
            contrast: 1.0,
            threshold: 128,
            flip_h: false,
            flip_v: false,
            rotation: 0,
            _line_spacing: 0.1, // mm
            dither: DitherMode::FloydSteinberg,
            use_skeleton: false,
            outline: OutlineParams::default(),
        }
    }
}

pub fn vectorize_image(img: &image::DynamicImage, params: &RasterParams) -> Vec<String> {
    let processed = preprocess_image(img, params);
    let gray = processed.to_luma8();
    let (iw, ih) = gray.dimensions();

    let target_w = (params.width_mm * params.dpi / 25.4) as u32;
    let target_h = (params.height_mm * params.dpi / 25.4) as u32;

    let resized = image::imageops::resize(&gray, target_w, target_h, image::imageops::FilterType::Lanczos3);
    let (rw, rh) = resized.dimensions();

    let mut gcode = Vec::new();
    gcode.push("; Vectorized by All4Laser".to_string());
    gcode.push(format!("; Source: {}x{} → {}x{}", iw, ih, rw, rh));
    gcode.push("G90".into());
    gcode.push("G21".into());
    gcode.push("M3".into());

    let x_scale = params.width_mm / rw as f32;
    let y_scale = params.height_mm / rh as f32;

    for y_idx in 0..rh {
        let py = (rh - 1 - y_idx) as f32 * y_scale;
        let mut in_run = false;
        let mut start_x = 0.0;

        for x_idx in 0..rw {
            let pixel = resized.get_pixel(x_idx, y_idx)[0];
            let is_black = pixel < params.threshold;

            if is_black && !in_run {
                in_run = true;
                start_x = x_idx as f32 * x_scale;
            } else if !is_black && in_run {
                in_run = false;
                let end_x = (x_idx - 1) as f32 * x_scale;
                gcode.push(format!("G0X{:.3}Y{:.3}S0", start_x, py));
                gcode.push(format!("G1X{:.3}Y{:.3}S{:.0}F{:.0}", end_x, py, params.max_power, params.max_speed));
            }
        }
        if in_run {
            let end_x = (rw - 1) as f32 * x_scale;
            gcode.push(format!("G0X{:.3}Y{:.3}S0", start_x, py));
            gcode.push(format!("G1X{:.3}Y{:.3}S{:.0}F{:.0}", end_x, py, params.max_power, params.max_speed));
        }
    }

    gcode.push("M5".into());
    gcode.push("G0X0Y0".into());
    gcode
}

/// Convert a raster image to GCode using line-scan with variable power
pub fn image_to_gcode(img: &image::DynamicImage, params: &RasterParams) -> Vec<String> {
    // 1. Preprocess (Brightness, Contrast, Grayscale)
    let processed = preprocess_image(img, params);
    let gray = processed.to_luma8();
    let (iw, ih) = gray.dimensions();

    // Resize to match target dimensions at given DPI
    let target_w = (params.width_mm * params.dpi / 25.4) as u32;
    let target_h = (params.height_mm * params.dpi / 25.4) as u32;

    let resized = image::imageops::resize(
        &gray, target_w, target_h,
        image::imageops::FilterType::Lanczos3,
    );

    let dithered = match params.dither {
        DitherMode::FloydSteinberg => floyd_steinberg_dither(&resized),
        DitherMode::Atkinson => atkinson_dither(&resized),
        DitherMode::None => resized,
    };
    let (rw, rh) = dithered.dimensions();

    let mut gcode = Vec::new();
    gcode.push("; Generated by All4Laser".to_string());
    gcode.push(format!("; Source: {}x{} → {}x{} pixels", iw, ih, rw, rh));
    gcode.push(format!("; Target: {:.1}x{:.1} mm", params.width_mm, params.height_mm));
    gcode.push("G90".to_string());       // Absolute
    gcode.push("G21".to_string());       // Millimeters
    gcode.push("M4".to_string());        // Dynamic laser mode

    let x_scale = params.width_mm / rw as f32;
    let y_scale = params.height_mm / rh as f32;

    for row in 0..rh {
        let y = row as f32 * y_scale;
        let reverse = row % 2 == 1; // Bidirectional scanning

        // Move to start of line
        let start_x = if reverse { params.width_mm } else { 0.0 };
        gcode.push(format!("G0X{start_x:.3}Y{y:.3}S0"));

        // Scan across - using G1 for the whole line and only modulating S
        let cols: Box<dyn Iterator<Item = u32>> = if reverse {
            Box::new((0..rw).rev())
        } else {
            Box::new(0..rw)
        };

        let mut first_col = true;
        for col in cols {
            let pixel = dithered.get_pixel(col, rh - 1 - row); // rh-1-row because row 0 is at Y=0
            let brightness = pixel[0];
            let power = ((255 - brightness) as f32 / 255.0 * params.max_power) as u32;
            let x = col as f32 * x_scale;

            if first_col {
                gcode.push(format!("G1X{x:.3}Y{y:.3}S{power}F{:.0}", params.max_speed));
                first_col = false;
            } else {
                gcode.push(format!("X{x:.3}S{power}"));
            }
        }
    }

    // --- Cutting Frame (Outline) ---
    if params.outline.enabled && params.outline.passes > 0 {
        gcode.push("; Cutting Frame".to_string());
        let w = params.width_mm;
        let h = params.height_mm;
        let s = params.outline.speed;
        let p = params.outline.power;

        for i in 0..params.outline.passes {
            gcode.push(format!("; Pass {}", i + 1));
            // Move to start of frame (bottom-left)
            gcode.push(format!("G0X0Y0S0"));
            // Trace rectangle
            gcode.push(format!("G1X{w:.3}Y0S{p}F{s}"));
            gcode.push(format!("G1X{w:.3}Y{h:.3}"));
            gcode.push(format!("G1X0Y{h:.3}"));
            gcode.push(format!("G1X0Y0"));
        }
        gcode.push("M5".to_string());
    }

    gcode.push("M5".to_string());
    gcode.push("G0X0Y0".to_string());
    gcode
}

/// Floyd-Steinberg dithering on a grayscale image
fn floyd_steinberg_dither(img: &GrayImage) -> GrayImage {
    let (w, h) = img.dimensions();
    let mut buf: Vec<Vec<f32>> = (0..h)
        .map(|y| (0..w).map(|x| img.get_pixel(x, y)[0] as f32).collect())
        .collect();

    for y in 0..h {
        for x in 0..w {
            let old = buf[y as usize][x as usize];
            let new_val = if old > 127.0 { 255.0 } else { 0.0 };
            buf[y as usize][x as usize] = new_val;
            let error = old - new_val;

            let spread = |buf: &mut Vec<Vec<f32>>, px: u32, py: u32, factor: f32| {
                if px < w && py < h {
                    buf[py as usize][px as usize] += error * factor;
                }
            };

            spread(&mut buf, x + 1, y, 7.0 / 16.0);
            if x > 0 { spread(&mut buf, x - 1, y + 1, 3.0 / 16.0); }
            spread(&mut buf, x, y + 1, 5.0 / 16.0);
            spread(&mut buf, x + 1, y + 1, 1.0 / 16.0);
        }
    }

    let mut output = GrayImage::new(w, h);
    for y in 0..h {
        for x in 0..w {
            let v = buf[y as usize][x as usize].clamp(0.0, 255.0) as u8;
            output.put_pixel(x, y, Luma([v]));
        }
    }
    output
}

/// Atkinson dithering (preserves more detail, higher contrast)
fn atkinson_dither(img: &GrayImage) -> GrayImage {
    let (w, h) = img.dimensions();
    let mut buf: Vec<Vec<f32>> = (0..h)
        .map(|y| (0..w).map(|x| img.get_pixel(x, y)[0] as f32).collect())
        .collect();

    for y in 0..h {
        for x in 0..w {
            let old = buf[y as usize][x as usize];
            let new_val = if old > 127.0 { 255.0 } else { 0.0 };
            buf[y as usize][x as usize] = new_val;
            let error = (old - new_val) / 8.0; // Atkinson spreads 1/8 to each neighbor

            let spread = |buf: &mut Vec<Vec<f32>>, px: u32, py: u32| {
                if px < w && py < h {
                    buf[py as usize][px as usize] += error;
                }
            };

            spread(&mut buf, x + 1, y);
            spread(&mut buf, x + 2, y);
            spread(&mut buf, x - 1, y + 1);
            spread(&mut buf, x, y + 1);
            spread(&mut buf, x + 1, y + 1);
            spread(&mut buf, x, y + 2);
        }
    }

    let mut output = GrayImage::new(w, h);
    for y in 0..h {
        for x in 0..w {
            let v = buf[y as usize][x as usize].clamp(0.0, 255.0) as u8;
            output.put_pixel(x, y, Luma([v]));
        }
    }
    output
}

/// Apply brightness and contrast adjustments
pub fn preprocess_image(img: &image::DynamicImage, params: &RasterParams) -> image::DynamicImage {
    let mut processed = img.clone();
    
    // Grayscale first to make processing faster and consistent
    processed = image::DynamicImage::ImageLuma8(processed.to_luma8());

    if params.brightness != 0.0 {
        // brightness(f32) where 0.0 is no change, -1.0 is black, 1.0 is white
        // The image crate uses i32 for brightness but it's easier to use f32 here
        processed = processed.brighten((params.brightness * 255.0) as i32);
    }

    if params.contrast != 1.0 {
        // contrast(f32) where 1.0 is no change
        // Wait, image::DynamicImage has adjust_contrast(f32)
        processed = processed.adjust_contrast(params.contrast);
    }

    if params.flip_h {
        processed = processed.fliph();
    }
    if params.flip_v {
        processed = processed.flipv();
    }

    processed = match params.rotation {
        90 => processed.rotate90(),
        180 => processed.rotate180(),
        270 => processed.rotate270(),
        _ => processed,
    };

    processed
}
